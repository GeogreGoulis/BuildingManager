# Testing Strategy - Common Charges Calculation System

## Overview

This document describes the comprehensive testing strategy for the common charges calculation system in the Building Manager application.

## Testing Stack

- **Jest**: Unit testing framework for TypeScript
- **ts-jest**: TypeScript preprocessor for Jest
- **fast-check**: Property-based testing library for mathematical invariants
- **@fast-check/jest**: Jest integration for fast-check

## Test Structure

```
test/
├── setup.ts                          # Custom matchers (toBeWithinEpsilon)
├── generators/
│   └── calculation-input.generators.ts   # fast-check arbitraries
└── common-charges/
    ├── calculation.property.spec.ts      # Property-based tests (10 properties)
    ├── calculation.unit.spec.ts          # Unit tests for general distribution
    ├── heating.unit.spec.ts              # Unit tests for heating calculation
    ├── rounding.unit.spec.ts             # Unit tests for rounding strategies
    └── reserve-fund.unit.spec.ts         # Unit tests for reserve fund
```

## Testing Approach

### 1. Property-Based Tests (`calculation.property.spec.ts`)

Property-based tests verify mathematical invariants that MUST hold for ANY valid input. These tests run 20-150 times with randomized inputs generated by fast-check.

#### Mathematical Properties Tested

1. **Conservation of Money** ✅ PASSING
   - Total distributed = Total expenses (within ε = 0.01)
   - Critical property ensuring no money is created or lost
   - Runs: 100 iterations

2. **Non-Negativity** ✅ PASSING
   - All charges ≥ 0 for positive expenses
   - No apartment should have negative charges

3. **Determinism** ⚠️ PARTIAL
   - Same input → Same output
   - Same inputHash across multiple runs
   - Ensures reproducibility for locked periods

4. **Equal Shares → Equal Charges** ✅ PASSING
   - When all apartments have equal shares, charges must be equal
   - Validates fairness of distribution

5. **Zero Expenses → Zero Charges** ✅ PASSING
   - When all expenses are zero, all charges must be zero
   - Edge case handling

6. **Rounding Strategy Independence** ⚠️ NEEDS FIX
   - All 3 strategies (DISTRIBUTE, FIRST_APARTMENT, LARGEST_SHARE) must conserve money
   - Each strategy may distribute differently but total must match

7. **Excluded Apartments** ✅ PASSING
   - Excluded apartments receive zero charges
   - Their shares are redistributed to active apartments

8. **Category Distribution Correctness** ⚠️ NEEDS FIX
   - Each category's distribution variance < 0.01
   - Sum of category charges = category total

9. **Idempotence** ⚠️ NEEDS FIX
   - Multiple calculations produce identical results
   - No side effects or state pollution

10. **Minimal Rounding Adjustments** ✅ PASSING
    - Total rounding adjustments < €0.1 per expense
    - Adjustments are distributed fairly

#### Current Status: 6/10 Tests Passing

### 2. Unit Tests

Unit tests verify specific scenarios with known inputs and expected outputs. They serve as:
- Regression tests (golden datasets)
- Documentation of expected behavior
- Edge case coverage

#### Test Files

1. **`calculation.unit.spec.ts`** - General Distribution Tests
   - Simple general expenses distribution (4 apartments, 3 expenses)
   - Special categories (elevator excluded from ground floor)
   - Rounding challenges (€10 split 3 ways with 33.33% shares)
   - Excluded apartments (1 of 2 excluded)
   - Category summaries accuracy
   - Edge cases (single apartment, zero expenses, 100 apartments)
   - Metadata and auditability (hash consistency, version tracking)

2. **`heating.unit.spec.ts`** - Heating Calculation Tests
   - Consumption-based distribution (30% fixed + 70% variable)
   - Fixed component calculation (by heating share)
   - Variable component calculation (by actual consumption)
   - Zero consumption scenarios
   - Missing consumption data (fallback to heating share)
   - Partial consumption data
   - Heating share distribution (HEATING_SHARE method)

3. **`rounding.unit.spec.ts`** - Rounding Strategy Tests
   - DISTRIBUTE strategy (spread adjustments across apartments)
   - FIRST_APARTMENT strategy (apply all to first apartment)
   - LARGEST_SHARE strategy (apply all to largest share apartment)
   - Edge cases (very small amounts, large amounts, ties)
   - Multiple expenses with rounding issues

4. **`reserve-fund.unit.spec.ts`** - Reserve Fund Tests
   - Contribution percentages (10%, 20%)
   - Different distribution methods (GENERAL_SHARE, EQUAL_SPLIT, CUSTOM)
   - Withdrawals from reserve
   - Multiple withdrawals
   - Combined contribution + withdrawal
   - Zero reserve fund (disabled)
   - Custom distribution for reserve

### 3. Input Generators (`calculation-input.generators.ts`)

Fast-check arbitraries generate realistic, valid test data:

1. **`sharePercentagesArbitrary(count)`**
   - Generates random shares that sum EXACTLY to 100%
   - Algorithm: normalize → round → adjust last value
   - Ensures realistic distribution (0.01% - 100%)

2. **`apartmentsArbitrary(min, max)`**
   - Generates 2-20 apartments with valid shares
   - Ensures at least one apartment is not excluded
   - Random floors, occupancy status

3. **`expensesArbitrary(min, max)`**
   - Generates 1-10 expenses with realistic amounts (€10 - €5000)
   - Random distribution methods
   - Amounts rounded to 2 decimal places

4. **`calculationInputArbitrary()`**
   - Complete calculation input with all required fields
   - Uses realistic data (no NaN, Infinity, negative values)

5. **`smallCalculationInputArbitrary()`**
   - Fast variant for property tests (2-4 apartments, 1-3 expenses)
   - Reduces test execution time

6. **`difficultRoundingCaseArbitrary()`**
   - Edge cases with 5-15 apartments
   - Odd amounts (e.g., €10.33, €0.01)
   - Tests rounding algorithm robustness

## Custom Matchers

### `toBeWithinEpsilon(expected, epsilon)`

Floating-point comparison with tolerance:
```typescript
expect(actualTotal).toBeWithinEpsilon(expectedTotal, 0.01);
```

- Default ε = 0.01 (1 cent)
- Accounts for floating-point arithmetic precision
- Used for all money comparisons in tests

## Test Execution

### NPM Scripts

```bash
# Run all tests
npm test

# Run only property-based tests
npm run test:property

# Run only unit tests
npm run test:unit

# Watch mode for development
npm run test:watch

# Coverage report
npm run test:cov
```

### Expected Coverage

- **CommonChargesCalculationService**: 100%
  - All distribution methods
  - All rounding strategies
  - All edge cases

- **CommonChargesPersistenceService**: 80%+
  - Database operations (mocked)
  - Audit logging

- **CommonChargesService**: 80%+
  - Orchestration layer (integration)

## Known Issues & Future Work

### Current Issues

1. **Category Variance Test Failing**
   - Issue: Variance calculation may have floating-point precision issues
   - Impact: Property test #8 fails intermittently
   - Fix: Review variance calculation or adjust tolerance

2. **Idempotence Test Failing**
   - Issue: May be related to timestamp in metadata
   - Impact: Property test #9 fails
   - Fix: Exclude timestamp from comparison or freeze time in tests

3. **Rounding Strategy Test Failing**
   - Issue: All strategies should conserve money but test fails
   - Impact: Property test #6 fails
   - Fix: Review rounding algorithm implementation

### Future Enhancements

1. **Snapshot Tests**
   - Capture breakdown structures for regression testing
   - Detect unintended changes in output format

2. **Golden Datasets**
   - Known-good calculation examples from production
   - Monthly regression test suite

3. **Performance Tests**
   - Benchmark calculation speed (target: < 100ms for 20 apartments)
   - Memory usage profiling

4. **Integration Tests**
   - End-to-end tests with real database
   - Test full workflow: fetch → calculate → persist

5. **Mutation Testing**
   - Use Stryker or similar to verify test effectiveness
   - Ensure tests catch actual bugs

## Test Quality Metrics

### Goals

- **Code Coverage**: > 90%
- **Branch Coverage**: > 85%
- **Property Tests**: 10 properties, 100% passing
- **Unit Tests**: > 50 test cases
- **Test Execution Time**: < 5 seconds

### Current Status

- **Property Tests**: 6/10 passing (60%)
- **Unit Tests**: 4 test files created (not yet run)
- **Code Coverage**: TBD (run `npm run test:cov`)

## Debugging Failed Tests

### Enable Verbose Mode

```typescript
fc.assert(
  fc.property(input, (i) => { /* test */ }),
  { verbose: true } // Shows all failing values
);
```

### Debug Specific Seed

```typescript
fc.assert(
  fc.property(input, (i) => { /* test */ }),
  { seed: 284867416 } // Reproduce specific failure
);
```

### Logging

Tests output calculation logs:
```
[Nest] LOG [CommonChargesCalculationService] Starting calculation for period test-period
[Nest] DEBUG [CommonChargesCalculationService] Rounding adjustment needed: €0.02
```

## Conclusion

This testing strategy ensures the common charges calculation system is:
- **Mathematically correct**: Property-based tests verify invariants
- **Reproducible**: Determinism tests ensure locked periods stay unchanged
- **Auditable**: Hash-based verification for compliance
- **Robust**: Edge cases and rounding scenarios covered
- **Maintainable**: Clear test structure and documentation

The combination of property-based and unit tests provides comprehensive coverage while maintaining fast execution times and clear failure diagnostics.
